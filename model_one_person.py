# модель игры с ботом
from random import randint
def proverochka2(mass0, k, s):
    '''функция, проверяющая квадрат 3*3, куда отправили бота, на двойки элементов
в ряд. сначала проверяет на двойки элементов, чем ходит бот, потом - на двойки
элементов человека(чтобы заблокировать выигрышный ход)'''
    m = s[1]# клетка поля 3*3 куда сходил человек. в поле 3*3 этого порядка должен ходить бот
    #t - клетка, куда ходит бот.
    # вычислим t
    a = mass0[m]
    for d in range(3): # 0,1,2
        if a[0+3*d] == a[1+3*d] == k:
            mass0[m][2+3*d] = k
            r = 2+3*d
        elif a[0+3*d] == a[2+3*d] == k:
            mass0[m][1+3*d] = k
            r = 1+3*d
        elif a[2+3*d] == a[1+3*d] == k:
            mass0[m][0+3*d] =k
            r = 0+3*d#string prov
        elif a[0+d] == a[3+d] == k:
            mass0[m][6+d] = k
            r = 6+d
        elif a[0+d] == a[6+d] == k:
            mass0[m][3+d] = k
            r = 3+d
        elif a[3+d] == a[6+d] == k:
            mass0[m][0+d] = k
            r = 0+d
            #проверка столбцов
        elif a[0] == a[4] == k:
            mass0[m][8] = k
            r = 8
            
        elif a[0] == a[8] == k:
            mass0[m][4] = k
            r = 4
        elif a[4] == a[8] == k:
            mass0[m][0]=k
            r = 0
        elif a[2] == a[4] == k:
            mass0[m][6] = k
            r = 6
        elif a[2] == a[6] == k:
            mass0[m][4] = k
            r = 4
        elif a[4] == a[6] == k:
            mass0[m][2] = k
            r = 2
        # проверка диагоналей
        # в предыдущих строках проверялся элемент бота
        # теперь проверим на двойки элемента человека
        if a[0+3*d] == a[1+3*d] != k and a[0+3*d]!=0 :
            mass0[m][2+3*d] = k
            r = 2 + 3*d
        elif a[0+3*d] == a[2+3*d] != k and a[0+3*d]!=0 :
            mass0[m][1+3*d] = k
            r = 1 +3*d
        elif a[2+3*d] == a[1+3*d] != k and a[2+3*d]!=0 :
            mass0[m][0+3*d] =k
            r = 0+3*d#string prov
        elif a[0+d] == a[3+d] != k and a[0+d]!=0 :
            mass0[m][6+d] = k
            r = 6 +d
        elif a[0+d] == a[6+d] != k and a[0+d]!=0 :
            mass0[m][3+d] = k
            r = 3+d
        elif a[3+d] == a[6+d] != k and a[3+d]!=0 :
            mass0[m][0+d] = k
            r = 0+d
            #проверка столбцов
        elif a[0] == a[4] != k and a[0]!=0 :
            mass0[m][8] = k
            r = 8
        
            
        elif a[0] == a[8] != k and a[0]!=0 :
            mass0[m][4] = k
            r = 4
        elif a[4] == a[8] != k and a[4]!=0 :
            mass0[m][0]=k
            r = 0
        elif a[2] == a[4]  != k and a[2]!=0 :
            mass0[m][6] = k
            r = 6
        elif a[2] == a[6] != k and a[2]!=0 :
            mass0[m][4] = k
            r = 4
        elif a[4] == a[6] != k and a[4]!=0 :
            mass0[m][2] = k
            r = 2
<<<<<<< HEAD
        else:
            return (mass0, -10)
=======

>>>>>>> 8e2a2a8396d4e84bf8c48c9724bbc164c7f801b3
        return (mass0,r)


def vygrali(mass1, mass0, k):
    '''в функцию подаётся массив главного поля 3*3
мы хотим определить, есть ли в какой-нибудь клетке хоть что- нибудь
то есть в этой клетке уже выиграли "vygrali"
массив большого поля нужен просто для проверки свободных клеток'''
    for j in range(9):
        for i in range (9):
            if mass1[i] != 0 and mass0[i][j] == 0:
<<<<<<< HEAD
                mass0[i][j] = k    
=======
                mass0[i][j] = k
                
>>>>>>> 8e2a2a8396d4e84bf8c48c9724bbc164c7f801b3
    return (mass0,j)
                    #возвращаем выигранное поле 3*3 со свободным местом

def bot_go(mass0, mass1, k, s):
    '''в функцию подается массив - поле 9*9
и число к, которое дает понять, чем ходит бот.
если к=1, то бот ходит крестиками
если к=2, то бот ходит ноликами
бот делает ход в массиве mass0 и в нужную клетку ставит 1 или 2,
что соот крестику или нолику
потом возвращает новый массив с выполненным ходом'''
    '''чтобы лучше понять, как сделать эту функцию,
надо, вероятно, ознакомиться со всей программой.
Как-то так. кря-кря 128.'''
    # квадрат 3*3 поля 9*9 куда сходил человек
    m = s[1]# клетка поля 3*3 куда сходил человек. в поле 3*3 этого порядка должен ходить бот
    #t=mass0[m][x] - клетка, куда ходит бот.
    # вычислим t
<<<<<<< HEAD
    if proverochka2(mass0, k, s)[0] != mass0: # мы проверили, есть ли возможность 3 в ряд
        s = proverochka2(mass0, k, s)
=======
    a = mass0[m]
    if proverochka2(mass0, k, s) != mass0: # мы проверили, есть ли возможность 3 в ряд
         mass0 = proverochka2(mass0, k, s)[0]
         a = proverochka2(mass0, k, s)[1]
>>>>>>> 8e2a2a8396d4e84bf8c48c9724bbc164c7f801b3
         
         

 
<<<<<<< HEAD
    elif vygrali(mass1, mass0, k)[0] != mass0:# проверили выигранные поля 3*3 со свободными местами
        s = vygrali(mass1, mass0, k)
=======
    elif vygrali(mass1, mass0, k) != mass0:# проверили выигранные поля 3*3 со свободными местами
        mass0 = vygrali(mass1, mass0, k)[0]
        a = vygrali(mass1, mass0, k)[1]
>>>>>>> 8e2a2a8396d4e84bf8c48c9724bbc164c7f801b3

    else : # надо отправить хоть куда-то на рандомное место квадрата, куда бота отправили
        for g in range(9):
            if mass0[m][g] == 0:
                mass0[m][g]=k
                a = g
<<<<<<< HEAD
                return(mass0,g)


# поставили то, чем ходит бот в вычисленную клетку
    return s #отдали новый массив 9*9 обратно
=======
                return (mass0,g)


# поставили то, чем ходит бот в вычисленную клетку
    return (mass0,a) #отдали новый массив 9*9 обратно
>>>>>>> 8e2a2a8396d4e84bf8c48c9724bbc164c7f801b3
    

