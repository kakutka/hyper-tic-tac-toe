# this is model for two players
import pygame
import numpy as np
def prov_field(event):
    '''проверяет попадание в поле 9 на 9 при нажатии мыши
можно использовать функцию prov_box()'''
    x, y = event
    if x>65 and x<65+270 and y>115 and y<115+270:
        return True
    else:
        return False
    #ffff


def event_mas(event):
    '''получает координаты положения
мышки и преобразовывает их в координаты центра той
клетки, куда попали. возврaщает новый кортеж mas'''
    x, y = event
    if y<115+30:
         y = 115+15
    elif y < 115+60:
        y = 115+45
    elif y< 115 +90:
        y = 115+75
    elif y < 115+ 120:
        y = 115 + 105
    elif y < 115+ 150:
        y = 115 + 135
    elif y < 115 + 180:
        y = 115+ 165
    elif y < 115 + 210:
        y = 115 + 195
    elif y < 115+240:
        y = 115 + 225
    elif y < 115 + 270:
        y = 115 + 255

    if x < 65+30:
        x = 65+15
    elif x<65+60:
        x = 65+45
    elif x < 65 + 90:
        x = 65+75
    elif x < 65 +120:
        x = 65 + 105
    elif x < 65 + 150:
        x = 65 + 135
    elif x < 65 + 180:
        x = 65 + 165
    elif x < 65 + 210:
        x = 65 + 195
    elif x < 65 + 240:
        x = 65 + 225
    elif x < 65 + 270:
        x = 65 + 255
                
    mas = (x,y)
    return mas
    #ffff

   
def mas_in_mass0(mas):
    mass00 = [
        [(65+15,115+15),(65+45, 115+15),(65+75, 115+15),(65+15,  115+45), (65+45, 115+45),(65+75, 115+45),(65+15,  115+75), (65+45, 115+75),(65+75, 115+75)],
        [(65+105, 115+15),(65+135, 115+15),(65+165, 115+15),(65+105, 115+45),(65+135, 115+45),(65+165, 115+45),(65+105, 115+75),(65+135, 115+75),(65+165, 115+75)],
        [(65+195, 115+15),(65+225, 115+15),(65+255, 115+15),(65+195, 115+45),(65+225, 115+45),(65+255, 115+45),(65+195, 115+75),(65+225, 115+75),(65+255, 115+75)],
        [(65+15,115+105),(65+45, 115+105),(65+75, 115+105),(65+15,  115+135), (65+45, 115+135),(65+75, 115+135),(65+15,  115+165), (65+45, 115+165),(65+75, 115+165)],
        [(65+105,115+105),(65+135, 115+105),(65+165, 115+105),(65+105, 115+135),(65+135, 115+135),(65+165, 115+135),(65+105, 115+165),(65+135, 115+165),(65+165, 115+165)],
        [(65+195, 115+105),(65+225, 115+105),(65+255, 115+105),(65+195, 115+135),(65+225, 115+135),(65+255, 115+135),(65+195, 115+165),(65+225, 115+165),(65+255, 115+165)],
        [(65+15,115+195),(65+45, 115+195),(65+75, 115+195),(65+15,  115+225), (65+45, 115+225),(65+75, 115+225),(65+15,  115+255), (65+45, 115+255),(65+75, 115+255)],
        [(65+105, 115+195),(65+135, 115+195),(65+165, 115+195),(65+105, 115+225),(65+135, 115+225),(65+165, 115+225),(65+105, 115+255),(65+135, 115+255),(65+165, 115+255)],
        [(65+195, 115+195),(65+225, 115+195),(65+255, 115+195),(65+195, 115+225),(65+225, 115+225),(65+255, 115+225),(65+195, 115+255),(65+225, 115+255),(65+255, 115+255)],
             ]
    for j in range(9):
        for i in range(9):
            if mass00[j][i]==mas:
                return (j, i)
    '''преобразовывает
координаты центра клетки в нужные значения
строк и столбцов для массива и возвращает их.
Массив состоит из 9 списков, которые в свою очередь
состоят из 9 клеток.
Координаты клетки в массиве определяются так:
В каждом квадрате мы идем слева направо и сверху вниз
то есть самая верхняя клетка поля 9*9 имеет координаты 0 и 0
Самая центральная имеет координаты 4, 4
Чуть вправо и вниз от центра - 4, 8
Самая правая клетка по центральной линии - 5, 5
Самая правая нижняя - 8 и 8
Чуть выше последней - 8 и 5'''
   

def mas_in_mass1(mas):
    '''то же самое, что и для mass0, но только для главной
    доски (главная доска/поле - это доска, на которой определяется, кто
    победит в партии). Тут правда одна координата.'''
    a = 365
    b = 205
    mass11 = [(a+15, b+15), (a+45, b+15), (a+75, b+15), (a+15, b+45), (a+45, b+45), (a+75, b+45), (a+15, b+75), (a+45, b+75), (a+75, b+75)]   
    for j in range(9):
        if mass11[j]==mas:
            return j


def mass0_in_mas(j, i):
    mass00 = [
        [(65+15,115+15),(65+45, 115+15),(65+75, 115+15),(65+15,  115+45), (65+45, 115+45),(65+75, 115+45),(65+15,  115+75), (65+45, 115+75),(65+75, 115+75)],
        [(65+105, 115+15),(65+135, 115+15),(65+165, 115+15),(65+105, 115+45),(65+135, 115+45),(65+165, 115+45),(65+105, 115+75),(65+135, 115+75),(65+165, 115+75)],
        [(65+195, 115+15),(65+225, 115+15),(65+255, 115+15),(65+195, 115+45),(65+225, 115+45),(65+255, 115+45),(65+195, 115+75),(65+225, 115+75),(65+255, 115+75)],
        [(65+15,115+105),(65+45, 115+105),(65+75, 115+105),(65+15,  115+135), (65+45, 115+135),(65+75, 115+135),(65+15,  115+165), (65+45, 115+165),(65+75, 115+165)],
        [(65+105,115+105),(65+135, 115+105),(65+165, 115+105),(65+105, 115+135),(65+135, 115+135),(65+165, 115+135),(65+105, 115+165),(65+135, 115+165),(65+165, 115+165)],
        [(65+195, 115+105),(65+225, 115+105),(65+255, 115+105),(65+195, 115+135),(65+225, 115+135),(65+255, 115+135),(65+195, 115+165),(65+225, 115+165),(65+255, 115+165)],
        [(65+15,115+195),(65+45, 115+195),(65+75, 115+195),(65+15,  115+225), (65+45, 115+225),(65+75, 115+225),(65+15,  115+255), (65+45, 115+255),(65+75, 115+255)],
        [(65+105, 115+195),(65+135, 115+195),(65+165, 115+195),(65+105, 115+225),(65+135, 115+225),(65+165, 115+225),(65+105, 115+255),(65+135, 115+255),(65+165, 115+255)],
        [(65+195, 115+195),(65+225, 115+195),(65+255, 115+195),(65+195, 115+225),(65+225, 115+225),(65+255, 115+225),(65+195, 115+255),(65+225, 115+255),(65+255, 115+255)],
             ]
    mas = mass00[j][i]
    return mas
    '''напротив, переводит координаты в массиве в координаты центра клетки на поле'''
    #fffff


def mass1_in_mas(i):
    a = 365
    b = 205
    mass11=[(a+15,b+15),(a+45,b+15),(a+75, b+15),(a+15,b+45),(a+45,b+45),
            (a+75,b+45),(a+15,b+75),(a+45,b+75),(a+75,b+75)]
    mas = mass11[i]
    return mas
    '''напротив, переводит координаты в массиве в
координаты центра клетки на поле'''

def prov_line_zero(coopl):
    '''проверяет, есть ли тройка ноликов
в переданном массиве. Если да, то возвращает True'''
    if coopl[0] == coopl[1] == coopl[2] == 2:
        return True
    elif coopl[3] == coopl[4] == coopl[5] == 2:
        return True
    elif coopl[6] == coopl[7] == coopl[8] == 2:
        return True
    elif coopl[0] == coopl[3] == coopl[6] == 2:
        return True
    elif coopl[1] == coopl[4] == coopl[7] == 2:
        return True
    elif coopl[2] == coopl[5] == coopl[8] == 2:
        return True
    elif coopl[0] == coopl[4] == coopl[8] == 2:
        return True
    elif coopl[2] == coopl[4] == coopl[6] == 2:
        return True
    else:
        return False
    
   

def prov_line_cross(coopl):
    '''проверяет, есть ли тройка крестиков
в переданном массиве. Если да, то возвращает True'''
    if coopl[0] == coopl[1] == coopl[2] == 1:
        return True
    elif coopl[3] == coopl[4] == coopl[5] == 1:
        return True
    elif coopl[6] == coopl[7] == coopl[8] == 1:
        return True
    elif coopl[0] == coopl[3] == coopl[6] == 1:
        return True
    elif coopl[1] == coopl[4] == coopl[7] == 1:
        return True
    elif coopl[2] == coopl[5] == coopl[8] == 1:
        return True
    elif coopl[0] == coopl[4] == coopl[8] == 1:
        return True
    elif coopl[2] == coopl[4] == coopl[6] == 1:
        return True
    else:
        return False


def rest_line0(mass0, line0, k):
    coopl = mass0[k]
    a = mass0_in_mas(k,0)
    b = mass0_in_mas(k,1)
    c = mass0_in_mas(k,2) 
    d = mass0_in_mas(k,3) 
    e = mass0_in_mas(k,4) 
    f = mass0_in_mas(k,5) 
    g = mass0_in_mas(k,6) 
    h = mass0_in_mas(k,7) 
    p = mass0_in_mas(k,8)
    if coopl[0] == coopl[1] == coopl[2] != 0:
        line0[k] = [a, b]
    elif coopl[3] == coopl[4] == coopl[5] != 0:
        line0[k] = [d,f]
    elif coopl[6] == coopl[7] == coopl[8] != 0:
        line0[k] = [g,p]
    elif coopl[0] == coopl[3] == coopl[6] != 0:
        line0[k] = [a,g]
    elif coopl[1] == coopl[4] == coopl[7] != 0:
        line0[k] = [b,h]
    elif coopl[2] == coopl[5] == coopl[8] != 0:
        line0[k] = [c,p]
    elif coopl[0] == coopl[4] == coopl[8] != 0:
        line0[k] = [a,p]
    elif coopl[2] == coopl[4] == coopl[6] != 0:
        line0[k] = [c,g]
    return line0[k]

        
    '''заполняет j массив массива line0 нужными координатами, которые
сама вычисляет из j подмассива массива mass0
фактически, делает то же, что и prov_line_zero, только
от ноликов берет их координаты, преобразовывает с помощью
mass0_in_mas(j, i) и заполняет line0[j]=[(ghg)(nnng)]'''


    
    
